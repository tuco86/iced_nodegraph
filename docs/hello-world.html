<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodeGraph Hello World - WASM Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        .demo-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo {
            font-size: 18px;
            font-weight: bold;
            color: #74c7ec;
        }

        .toolbar-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .toolbar-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .toolbar-button.primary {
            background: linear-gradient(135deg, #74c7ec 0%, #89b4fa 100%);
            color: #1e1e2e;
            border-color: #74c7ec;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #a6e3a1;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .demo-canvas {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #nodeGraphCanvas {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1b26 0%, #24283b 100%);
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 0.5s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #74c7ec;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .loading-subtitle {
            font-size: 14px;
            opacity: 0.7;
            text-align: center;
            max-width: 400px;
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
        }

        .controls-hint h4 {
            color: #74c7ec;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .controls-hint ul {
            list-style: none;
            line-height: 1.6;
        }

        .controls-hint li {
            margin-bottom: 4px;
        }

        .controls-hint .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            text-align: center;
            z-index: 1000;
        }

        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
        }

        @media (max-width: 768px) {
            .toolbar {
                flex-direction: column;
                gap: 10px;
                padding: 15px;
            }
            
            .toolbar-left,
            .toolbar-right {
                width: 100%;
                justify-content: center;
            }
            
            .controls-hint {
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <div class="toolbar">
            <div class="toolbar-left">
                <div class="logo">üéØ NodeGraph Hello World</div>
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span id="statusText">Loading WASM...</span>
                </div>
            </div>
            <div class="toolbar-right">
                <a href="demo.html" class="toolbar-button">üîß API Demo</a>
                <a href="/" class="toolbar-button">üè† Home</a>
                <button id="fullscreenBtn" class="toolbar-button">‚õ∂ Fullscreen</button>
            </div>
        </div>

        <div style="margin: 10px 20px; padding: 12px; background: rgba(116, 199, 236, 0.15); border-left: 4px solid #74c7ec; border-radius: 6px; font-size: 14px;">
            <strong>üíé WebGPU Rendering:</strong> Full GPU acceleration with custom shaders (Chrome 113+, Edge 113+)
            <br/>
            <strong>ÔøΩ Auto-fallback:</strong> WebGL for older browsers ‚Ä¢ Interactive Canvas2D visualization below
            <br/>
            <strong>üñ•Ô∏è Native:</strong> <code style="background: rgba(0,0,0,0.4); padding: 2px 8px; border-radius: 4px; font-family: monospace;">cargo run --example hello_world</code>
        </div>

        <div class="demo-canvas" id="demoCanvas">
            <canvas id="nodeGraphCanvas"></canvas>
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>
                <div class="loading-text">Initializing NodeGraph Demo</div>
                <div class="loading-subtitle">
                    Loading the complete Hello World example with interactive node graph, 
                    drag-and-drop functionality, and live theme switching...
                </div>
            </div>
        </div>

        <div class="controls-hint" id="controlsHint">
            <h4>üéÆ Interactive Controls</h4>
            <ul>
                <li><span class="key">Cmd+K</span> - Open command palette</li>
                <li><span class="key">‚Üë‚Üì</span> - Navigate menu</li>
                <li><span class="key">Enter</span> - Confirm selection</li>
                <li><span class="key">Esc</span> - Cancel/Close</li>
                <li><span class="key">Drag</span> - Move nodes</li>
                <li><span class="key">Drag pins</span> - Connect edges</li>
            </ul>
        </div>
    </div>

    <script type="module">
        let wasm;
        let demoRunning = false;
        
        // Canvas2D variables - no longer used (Iced creates its own canvas)
        // let canvas, ctx;
        // let nodes = [];
        // let edges = [];
        // let draggedNode = null;
        // let draggedPin = null;
        // let tempEdge = null;

        // Node structure from hello_world.rs - for reference only
        /* const nodeData = [
            { x: 100, y: 150, name: "üìß Email Trigger", 
              pins: [{ side: 'right', type: 'out', label: 'on email', color: '#4db8ff' }] },
            { x: 350, y: 150, name: "üì® Email Parser",
              pins: [
                { side: 'left', type: 'in', label: 'email', color: '#4db8ff' },
                { side: 'right', type: 'out', label: 'subject', color: '#ffb84d' },
                { side: 'right', type: 'out', label: 'datetime', color: '#b84dff' },
                { side: 'right', type: 'out', label: 'body', color: '#ffb84d' }
              ]
            },
            { x: 350, y: 350, name: "üîç Filter",
              pins: [
                { side: 'left', type: 'in', label: 'input', color: '#ffb84d' },
                { side: 'right', type: 'out', label: 'matches', color: '#ffb84d' }
              ]
            },
            { x: 650, y: 250, name: "üìÖ Create Event",
              pins: [
                { side: 'left', type: 'in', label: 'datetime', color: '#b84dff' },
                { side: 'left', type: 'in', label: 'title', color: '#ffb84d' },
                { side: 'left', type: 'in', label: 'description', color: '#ffb84d' }
              ]
            }
        ];

        const edgeData = [
            { from: [0, 0], to: [1, 0] },  // Email Trigger -> Email Parser
            { from: [1, 1], to: [2, 0] },  // Email Parser subject -> Filter
            { from: [1, 2], to: [3, 0] },  // Email Parser datetime -> Calendar
            { from: [2, 1], to: [3, 1] }   // Filter -> Calendar title
        ]; */

        async function init() {
            const statusText = document.getElementById('statusText');
            const loadingOverlay = document.getElementById('loadingOverlay');
            
            try {
                // Detect WebGPU support
                const hasWebGPU = 'gpu' in navigator;
                if (hasWebGPU) {
                    console.log('‚úÖ WebGPU is available! WGPU will use GPU acceleration.');
                    try {
                        const adapter = await navigator.gpu?.requestAdapter();
                        if (adapter) {
                            const info = await adapter.requestAdapterInfo();
                            console.log('üéÆ GPU Adapter:', info.vendor, info.architecture || 'unknown');
                        }
                    } catch (e) {
                        console.log('‚ö†Ô∏è WebGPU available but adapter request failed:', e.message);
                    }
                } else {
                    console.log('‚ÑπÔ∏è WebGPU not available. WGPU will fallback to WebGL/Canvas2D.');
                }
                
                statusText.textContent = 'Loading WASM module...';
                
                // Import WASM module
                wasm = await import('../pkg/iced_nodegraph.js');
                await wasm.default();
                
                statusText.textContent = hasWebGPU ? 'Starting WebGPU application...' : 'Starting application...';
                
                // Hide loading overlay immediately
                loadingOverlay.classList.add('hidden');
                
                // Start the Iced application - this will take over rendering with WGPU!
                // This is an async operation that returns when the app is ready
                statusText.textContent = 'Launching Iced/WGPU...';
                console.log('üöÄ Starting Iced application with WGPU rendering...');
                
                await wasm.run_hello_world();
                
                // If we get here, the app started successfully
                statusText.textContent = 'WGPU app running!';
                demoRunning = true;
                
                console.log('‚úÖ Iced WGPU application started successfully!');
                
            } catch (error) {
                console.error('‚ùå Failed to start demo:', error);
                statusText.textContent = 'Failed to load demo';
                showError(error);
                loadingOverlay.classList.add('hidden');
            }
        }

        // Canvas2D rendering disabled - Iced/WGPU handles all rendering now
        /*
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        function render() {
            if (!demoRunning) return;
            
            // Clear canvas
            ctx.fillStyle = '#1a1b26';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid (subtle)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw edges
            drawEdges();
            
            // Draw temporary edge while dragging
            if (tempEdge) {
                ctx.strokeStyle = '#74c7ec';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(tempEdge.start.x, tempEdge.start.y);
                ctx.lineTo(tempEdge.end.x, tempEdge.end.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw nodes
            nodes.forEach(node => drawNode(node));
            
            requestAnimationFrame(render);
        }

        function drawNode(node) {
            const width = 180;
            const headerHeight = 30;
            const pinHeight = 24;
            const pinCount = node.pins.length;
            const height = headerHeight + pinCount * pinHeight + 10;
            
            // Node shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            
            // Node background
            ctx.fillStyle = '#2d2d3d';
            ctx.fillRect(node.x, node.y, width, height);
            
            ctx.shadowColor = 'transparent';
            
            // Node border
            ctx.strokeStyle = '#45475a';
            ctx.lineWidth = 2;
            ctx.strokeRect(node.x, node.y, width, height);
            
            // Header
            ctx.fillStyle = '#363748';
            ctx.fillRect(node.x, node.y, width, headerHeight);
            
            ctx.fillStyle = '#cdd6f4';
            ctx.font = '14px -apple-system, sans-serif';
            ctx.fillText(node.name, node.x + 10, node.y + 20);
            
            // Pins
            node.pins.forEach((pin, idx) => {
                const pinY = node.y + headerHeight + idx * pinHeight + 12;
                const pinX = pin.side === 'left' ? node.x : node.x + width;
                
                // Pin circle
                ctx.fillStyle = pin.color;
                ctx.beginPath();
                ctx.arc(pinX, pinY, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#1a1b26';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Pin label
                ctx.fillStyle = '#a6adc8';
                ctx.font = '11px -apple-system, sans-serif';
                const labelX = pin.side === 'left' ? node.x + 20 : node.x + width - 80;
                ctx.fillText(pin.label, labelX, pinY + 4);
                
                // Store pin position for interaction
                pin.x = pinX;
                pin.y = pinY;
            });
        }

        function drawEdges() {
            edges.forEach(edge => {
                const fromNode = nodes[edge.from[0]];
                const toNode = nodes[edge.to[0]];
                if (!fromNode || !toNode) return;
                
                const fromPin = fromNode.pins[edge.from[1]];
                const toPin = toNode.pins[edge.to[1]];
                if (!fromPin || !toPin) return;
                
                // Bezier curve for edges
                const startX = fromPin.x;
                const startY = fromPin.y;
                const endX = toPin.x;
                const endY = toPin.y;
                
                const controlOffset = Math.abs(endX - startX) / 2;
                const cp1x = startX + controlOffset;
                const cp1y = startY;
                const cp2x = endX - controlOffset;
                const cp2y = endY;
                
                ctx.strokeStyle = fromPin.color;
                ctx.lineWidth = 2.5;
                ctx.shadowColor = fromPin.color;
                ctx.shadowBlur = 5;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                ctx.stroke();
                
                ctx.shadowColor = 'transparent';
            });
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on a node
            for (let node of nodes) {
                if (x >= node.x && x <= node.x + 180 && 
                    y >= node.y && y <= node.y + 30) {
                    draggedNode = { node, offsetX: x - node.x, offsetY: y - node.y };
                    return;
                }
                
                // Check if clicking on a pin
                for (let pin of node.pins) {
                    const dist = Math.sqrt((x - pin.x) ** 2 + (y - pin.y) ** 2);
                    if (dist < 10) {
                        draggedPin = { node, pin };
                        tempEdge = { start: { x: pin.x, y: pin.y }, end: { x, y } };
                        return;
                    }
                }
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (draggedNode) {
                draggedNode.node.x = x - draggedNode.offsetX;
                draggedNode.node.y = y - draggedNode.offsetY;
            } else if (tempEdge) {
                tempEdge.end = { x, y };
            }
        }

        function handleMouseUp(e) {
            if (draggedPin) {
                // Check if releasing over another pin
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                for (let node of nodes) {
                    for (let pin of node.pins) {
                        const dist = Math.sqrt((x - pin.x) ** 2 + (y - pin.y) ** 2);
                        if (dist < 10 && pin !== draggedPin.pin) {
                            // Create new edge
                            const fromIdx = nodes.indexOf(draggedPin.node);
                            const fromPinIdx = draggedPin.node.pins.indexOf(draggedPin.pin);
                            const toIdx = nodes.indexOf(node);
                            const toPinIdx = node.pins.indexOf(pin);
                            
                            edges.push({ from: [fromIdx, fromPinIdx], to: [toIdx, toPinIdx] });
                            console.log(`üîó Edge created: node ${fromIdx} pin ${fromPinIdx} -> node ${toIdx} pin ${toPinIdx}`);
                        }
                    }
                }
            }
            
            draggedNode = null;
            draggedPin = null;
            tempEdge = null;
        }
        */
        // End Canvas2D code - all rendering is now handled by Iced/WGPU

        function showError(error) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.innerHTML = `
                <h3>‚ö†Ô∏è Demo Failed to Load</h3>
                <p><strong>Error:</strong> ${error.message}</p>
                <p>This could be due to:</p>
                <ul style="text-align: left; margin: 10px 0;">
                    <li>Complex Iced application architecture limitations in WASM</li>
                    <li>Browser WASM compatibility constraints</li>
                    <li>Network connectivity issues</li>
                </ul>
                <p>
                    <strong>Note:</strong> The full Hello World example with interactive NodeGraph, 
                    drag-and-drop, and live theme switching works perfectly in native Rust! 
                    For the complete experience, try the <a href="demo.html" style="color: #74c7ec;">API Demo</a> 
                    or run the native example locally.
                </p>
            `;
            document.body.appendChild(errorDiv);
        }

        // Fullscreen functionality
        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen failed:', err);
                });
            } else {
                document.exitFullscreen();
            }
        });

        // Hide controls hint after demo starts
        setTimeout(() => {
            const hint = document.getElementById('controlsHint');
            if (demoRunning && hint) {
                hint.style.opacity = '0.7';
                hint.style.transform = 'translateY(10px)';
            }
        }, 10000);

        // Keyboard shortcut info
        document.addEventListener('keydown', (e) => {
            if (e.metaKey && e.key === 'k') {
                console.log('üé® Command palette triggered (Cmd+K)');
            }
        });

        // Initialize when page loads
        init();
    </script>
</body>
</html>